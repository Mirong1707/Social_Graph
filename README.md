# Social_Graph
Что бы спарсить друзей, мы сформировали удобный для анализа json файл. Далее одна из версий парсинга вк.
%%(python)
import requests
import json

all_id = []

for i in range(13):
    print(i)
    res = requests.get(f"https://api.vk.com/method/groups.getMembers?group_id=45&offset={i * 1000}&count=1000"
                       f"&access_token=4b32289d4b32289d4b32289d1d4b40471c44b324b32289d15e80a8caa89b73d1d2a5579&v=5.107")
    all_id.extend(json.loads(res.text)['response']['items'])

with open('ids.json', 'w') as f:
    f.write(json.dumps({'ids': all_id}))
%%

Далее json был преобразован в удобные два файла. В одном список всех вершин графа, во втором на каждой строчке описывается ребро, двумя вершинами.Далее код, формирующий текстовый файл.
%%(python)
txt = "test.txt"
f = open(txt).read()
ans = open('rebra.txt', 'w')
arr = []
flag = False
k = 0
check = 1
for i in f:
    if not (ord('0') <= ord(i) <= ord('9')):
        if k != 0:
            if check == 1:
                ans.write(str(k) + ' ')
            else:
                ans.write(str(k) + '\n')
            check *= -1
        k = 0
        flag = False
    if not flag and ord('0') <= ord(i) <= ord('9'):
        flag = True
    if flag and ord('0') <= ord(i) <= ord('9'):
        k = k * 10 + int(i)
print(arr)

%%
Теперь для дальнейшего анализы была сформирована таблица вершин и ребер в xlsx файле. Код формирования таблицы будет приведен далее, так как он довольно схож при решении двух задач. Теперь эти таблицы можно экспортировать в gephi. Это визуализатор графов. Вот так выглядит весь граф целиком. Сразу можно заметить Несколько вершин гигантов (размер вершины графа пропорционален её степени). Это страницы двух учителей https://vk.com/id238683 и  https://vk.com/id133883. Они тесно связаны с организацией различной внеурочной деятельности в школе, и следовательно много общаются со всеми классами в школе, поэтому различных связей так много. Например Янина Ядова дала нам возможность попасть на эту стажировку. 
file:/users/ghanin03/projects/socialgraph/1.png
Сразу можно заметить, что вершины с наибольшим количеством связей обычно учителя, и таким образом их не сложно выделить из общей массы. 
Теперь я провел небольшое расследование ручками. Поскольку к графу применяется физическая модель, то он выделяет сообщества, они похожи на сгруппировавшиеся в кучку вершины. Я выбрал небольшой подграф, и характеризовал каждую группу, списавшись с некоторыми её участниками, и узнав, как они связаны с нашей школой.
file:/users/ghanin03/projects/socialgraph/2.jpg
Класс человека я определял напрямую, спрашивая у всех в вк, под предлогом исследования. И так, под группой 1 на фото представлено сообщество нынешних классов 11-1 и 11-2. Они так тесно связаны, так как перемешивались по ходу обучения. То есть бывший при переходе из 7 класса в 8, нас грубо говоря отсортировали по интересам(математика или физика), но старые связи остались. Да и в общем, эти два класса довольно тесно общаются между собой, говорю как ученик одного из них. Под номеров 2 - 11-3 класс, 3 - 11-5 класс, 4 - 11-7, а под вопросом находятся 3 человека из 11-4. Их класс плохо спарсился, так как многие страницы либо не подписаны на группу, либо закрыты. В итоге всего несколько человек находятся в окружении других классов из параллели, и остальные либо размазаны среди других классов, либо их вообще нет в графе. Как можно заметить, сообщества формируются довольно четко, и вручную их разделить не составляет проблем. 

Но выделять все руками довольно долго и не практично. Поэтому был придуман алгоритм выделения класса по id одного его участника. То есть выделяется компонента сильной связанности, которой принадлежит рассматриваемый участник. Вот код, который это выполняет.
%%(python)
import requests
import json


def findFriend(id, da):
    ss = set()
    for i in d[id]:
        ss.add(i)
    ds = {}
    for i in ss:
        ds[i] = 0
        for j in d[i]:
            for k in ss:
                if k == j:
                    ds[i] += 1
                    break

    anss = []
    for i in ss:
        anss.append((ds[i], i))
    anss = sorted(anss, reverse=True)
    k = 1
    for i in anss:
        if not da.get(i[1]) is None:
            da[i[1]] += k
            k *= 0.95


def GetNameById(user_id):
    res = requests.get(f"https://api.vk.com/method/users.get?user_ids={user_id}&"
                       f"access_token=4b32289d4b32289d4b32289d1d4b40471c44b324b32289d15e80a8caa89b73d1d2a5579&v=5.107&lang=ru")
    res = json.loads(res.text)['response'][0]
    return res['first_name'] + ' ' + res['last_name']


f = open("rebra.txt").read().split("\n")
d = {}
st = set()
for ind, i in enumerate(f):
    a = 0
    b = 0
    j = 0
    flag = False
    while j < len(i):
        if i[j] == ' ':
            flag = True
            j += 1
            continue
        if not flag:
            a = a * 10 + int(i[j])
        else:
            b = b * 10 + int(i[j])
        j += 1
    st.add(a)
    st.add(b)
    if d.get(a) is None:
        d[a] = []
    if d.get(b) is None:
        d[b] = []
    d[a].append(b)
    d[b].append(a)
id0 = 420403096
suspected = set()
for i in d[id0]:
    suspected.add(i)
ds = {}
dans = {}
for i in suspected:
    dans[i] = 0
ii = 0
findFriend(id0, dans)
ans = []
for i in suspected:
    ans.append((dans[i], i))
ans = sorted(ans, reverse=True)
for i in ans:
    findFriend(i[1], dans)
    if ii > 10:
        break
    ii += 1

ans = []
for i in suspected:
    ans.append((dans[i] / (len(d[i]) + 5), i))
ans = sorted(ans, reverse=True)
jj = 0
for i in ans:
    print(i[0], GetNameById(i[1]), jj)
    jj += 1
    if jj > 30:
        break


%%
Если описать алгоритм в двух словах, то мы просто берем все вершины, с которыми связаны рассматриваемая, а дальше выделяем первых 30 участников, которые тесно связаны между собой. Но так же этот алгоритм применяется для нескольких других вершин из друзей рассматриваемых, для того чтобы исключить ложные компоненты связанности, с которыми рассматриваемая вершина связана всего парой ребр.
И так, я применил этот алгоритм на своей странице, и получил следующий результат. Он на 90 процентов верный. Но так же тут выведен наш классный руководитель(хотя может и можно считать его за участника класса), и пара людей из 11-2, так как я уже говорил, что с ними у нас тесные социальные связи.
file:/users/ghanin03/projects/socialgraph/3.jpg

Далее была сделана гистограмма. Теперь я прикладываю код, который формирует xlsx таблицу, на что я ссылался выше.
%%(python)
from openpyxl import load_workbook

wb = load_workbook('t1.xlsx')
sheet = wb.get_sheet_by_name('test')
f = open("rebra.txt").read().split("\n")
ans = []
d = {}
dd = {}
st = set()
ii = 0
for ind, i in enumerate(f):
    ans.append([])
    a = 0
    b = 0
    j = 0
    flag = False
    while j < len(i):
        if i[j] == ' ':
            flag = True
            j += 1
            continue
        if not flag:
            a = a * 10 + int(i[j])
        else:
            b = b * 10 + int(i[j])
        j += 1
    if(a > b):
        a, b = b, a
    if dd.get((a, b)) is None:
        dd[(a, b)] = 1
        st.add(a)
        st.add(b)
        if d.get(a) is None:
            d[a] = 0
        if d.get(b) is None:
            d[b] = 0
        d[a] += 1
        d[b] += 1
st1 = set()
d1 = {}
check = 0
for i in st:
    st1.add(d[i])
    check += 1
    if d1.get(d[i]) is None:
        d1[d[i]] = 0
    d1[d[i]] += 1
ans1 = []
iii = 0
for i in st1:

    ans1.append([i, d1[i]])
    sheet[f'A{iii + 2}'] = i
    sheet[f'B{iii + 2}'] = d1[i]
    iii += 1
ans1 = sorted(ans1)
print(ans1)

wb.save('t1.xlsx')

%%
В построенной таблице хранятся два столбца. В первом количество связей, а во втором количество вершин, с таким количеством связей. По этим данным был построен график.
file:/users/ghanin03/projects/socialgraph/4.jpg
Сложно рассуждать почему распределение именно такое. Особенно странно что так много вершин с малым количеством связей. На мой взгляд это может объясняется тем, что люди, интересующиеся нашей школой подписываются на группы. Но интерес редко перерастает в то, что человек либо его дети сюда поступают, а от группы отписаться забывают. Стоит помнить, что на графике отсутствует первая точка, для 0 связей, где порядка 2500 вершин, что подтверждает вышеописанную теорию
Так же было проведено исследование зависимости возраста участников группы. Медот формирования таблицы тот же. Вот получившийся график зависимости. Понятно, что он не точен, так как многие указывают неверный возраст (более 100 лет) но в средней зависимость имеет смысл.file:/users/ghanin03/projects/socialgraph/5.jpg
На этом можно считать исследование завершенным. Спасибо за внимание.
